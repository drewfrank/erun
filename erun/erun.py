#!/usr/bin/env python2
"""
Output a batch of commands corresponding to a single experiment and store metadata.

This utility makes a number of assumptions to simplify its implementation.
Specifically, in order for it to work properly the base command must satisfy
the following requirements:

    - Accept only one positional argument (the path to the input file).
    - Do not support multiple options with the same functionality (i.e. do not
      make both --dims and -d mean the same thing). This would cause problems
      when querying the metadata file using equery.
    - All options must begin with '-' or '--'.

To sweep over a range of values for a parameter the following syntax is supported:

    set:FOO,BAR,BAZ : A set of possible values.
    range:start,stop : A range of integer values from start to stop, inclusive.
        e.g. range:2,4 == set:2,3,4
    range:start,stop,step : A range of values from start to stop in increments
        of step.

Spaces before or after punctuation are NOT permitted. Any values specified without
one of these constructs will be automatically converted to a set with a single value,
and one command will be generated for each element in the cross-product of the
domains.
"""
import argparse
import itertools
import json
import md5
import os
import textwrap

FP_PREC = 1e-8 # Numbers that differ by less than this quantity are assumed equal.

def parse_args():
    parser = argparse.ArgumentParser(
            formatter_class=argparse.RawDescriptionHelpFormatter,
            description='Prepare a set of commands to run a single experiment.',
            epilog=textwrap.dedent("""
            Specifying argument combinations for the experiment script
            ----------------------------------------------------------
            Of the options listed above, "-r", "-o", "-h", and "-i" are given
            special treatment by the erun executable. All other options
            specified when calling erun are treated as options of the experiment
            script and determine the set of commands generated by erun.

            For example:
              erun -r ./trial -o results -i input.txt -x 1 --foo bar
            produces a single command as output:
              ./trial -o results/<OUTFILE> -x 1 --foo bar input.txt
            where OUTFILE is a randomly generated filename for the results.
            
            To ease the task of specifying many argument combinations, erun
            has syntax for several "special" argument types:

              - set:<value>[,<value>]*
                A set of values.

              - range:<start>,<stop>[,<step>]
                A range of values from <start> to <stop>, in increments of
                <step> (with a default step size of 1). A range is inclusive
                unless it does not divide evenly into increments of <step>,
                in which case <stop> is excluded. Note that, for example,
                set:2,4,6,8 is equivalent to range:2,8,2. Non-integer values
                are also supported.
                
            Each option with a special argument value actually refers to a
            set of concrete values. erun interprets these by generating
            one command line (trial) for each element in the Cartesian product
            of these sets. For example, the following invocations:
              erun -r ./trial -o results -i input.txt \\
                      -x range:1,2 -y --foo set:bar,baz
            will generate four commands:
              ./trial -o results/[OUTFILE] -x 1 -y --foo bar input.txt
              ./trial -o results/[OUTFILE] -x 1 -y --foo baz input.txt
              ./trial -o results/[OUTFILE] -x 2 -y --foo bar input.txt
              ./trial -o results/[OUTFILE] -x 2 -y --foo baz input.txt
            Note that since the option "-y" does not have a special
            value it is included unaltered in every command.

            Spaces around punctuation are not allowed in any of the special
            arguments.

            Experiment script command line interface
            ----------------------------------------
            erun makes a few assumptions about the command-line interface of the
            experiment script:
             - It must accept its output file name via "-o FILE".
             - It must accept its input file as its sole positional argument.
             - If it parses long options, it must accept the format "--long ARG"
               rather than (or in addition to) "--long=ARG".
             - All options must begin with "-" or "--".
             - It should not accept multiple spellings of the same option, e.g.
               "-d" and "--dims" having the same behavior. If erun is called
               multiple times using different forms of the same option,
               subsequent queries may not return all relevant results.
             - It must not accept long and short options with the same name,
               e.g. -a and --a. That's just a bad idea, anyway.
            """))
    parser.add_argument('-r', required=True, metavar='MAIN_SCRIPT', type=str,
            help='The experiment script for running a single trial.')
    parser.add_argument('-o', required=True, metavar='OUT_DIR', type=str, 
            help='Directory for the result files.')
    parser.add_argument('-FLAG',
            help='Simple flag to be passed through to the experiment script. Multiple such flags are allowed.')
    parser.add_argument('-SHORT_OPT', metavar='ARG', type=str, 
            help='Short option with argument to be passed through to the experiment script. Multiple such options are allowed.')
    parser.add_argument('--LONG_OPT', metavar='ARG', type=str, 
            help='Long option with argument to be passed through to the experiment script. Multiple such options are allowed.')
    parser.add_argument('-i', required=True, metavar='FILE', nargs='+', type=str, 
            help='Input files to process.')
    return parser.parse_known_args()

def main():
    args, params = parse_args()
    solo_flags, arg_flags = parse_params(params)
    base_cmd = ' '.join([args.r, ' '.join(solo_flags)])
    metadata_file = os.path.join(args.o, 'METADATA')
    metadata = load_metadata(metadata_file)
    for vals in itertools.product(*arg_flags.values()):
        arg_pairs = zip(arg_flags.keys(), vals)
        arg_str = ' '.join(map(' '.join, arg_pairs))
        for file in args.i:
            outfile = os.path.join(args.o, outfile_name(base_cmd + arg_str + file))
            cmd = ' '.join([base_cmd, arg_str, '-o', outfile, file])
            metadata.append(compose_metadata(
                    args.r, solo_flags, arg_pairs, file, outfile, cmd))
            print cmd
    store_metadata(open(metadata_file, 'w'), metadata)

def process_arg(x):
    """Process an argument and create a list of possible values."""
    if x.lower().startswith('set:'):
        return x[x.find(':')+1:].split(',')
    elif x.lower().startswith('range:'):
        sss = x[x.find(':')+1:].split(',')
        if len(sss) == 2:
            start, stop = map(float, sss[:2])
            step = 1
        if len(sss) == 3:
            start, stop, step = map(float, sss)
        return [str(intify(x)) for x in frange(start, stop, step)]
    else:
        return [x]

def parse_params(params):
    """Manually parse arguments that argparse doesn't know about."""
    def isoption(x):
        return x.startswith('-')
    solo_flags = []
    arg_flags = dict()
    i = 0
    while i < len(params):
        if not isoption(params[i]):
            raise ValueError('"' + params[i] + '" does not look like an option.')
        if i == len(params) - 1 or isoption(params[i+1]):
            solo_flags.append(params[i])
            i += 1
            continue
        else:
            arg_flags[params[i]] = process_arg(params[i+1])
            i += 2
            continue
    return solo_flags, arg_flags

def load_metadata(file_path):
    if os.path.exists(file_path):
        return json.load(open(file_path))
    else:
        return []

def store_metadata(fh, metadata):
    """Write the metadata for this experiment to a file."""
    json.dump(metadata, fh, indent=2)


def compose_metadata(cmd, solo_flags, arg_flags, infile, outfile, full_cmd):
    """Create a metadata entry for a single trial."""
    return {
        'outfile': os.path.split(outfile)[-1],
        'cmd': cmd,
        'infile': infile,
        'solo_flags': solo_flags,
        'arg_flags': {k.lstrip('-'):v for k, v in arg_flags},
        'full_cmd': full_cmd
    }

def outfile_name(cmd):
    """Generate an output filename by hashing the (partial) command line."""
    return md5.md5(cmd).hexdigest()[:8]

def frange(start, stop, step=1):
    """Like xrange, but inclusive and handles floats."""
    while start < stop:
        yield start
        start += step
    # Simple hack to handle floating point precision issues nicely,
    # most of the time :).
    if almost_equal(start, stop):
        yield start

def almost_equal(x, y):
    """Check if two numbers are equal up to FP_PREC."""
    return abs(x-y) < FP_PREC

def intify(x):
    """Return the nearest integer if it's almost equal to x."""
    return int(x) if almost_equal(x, round(x)) else x

if __name__ == '__main__':
    main()
